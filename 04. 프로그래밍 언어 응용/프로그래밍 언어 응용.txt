

4. 프로그래밍 언어 응용

인텔라j 다운로드 설치

설정
파일->세팅->테마(theme)설정->Editor->General->Auto Import
->java-add,Option 체크 후 Apply 클릭
->font 설정 -> Main 마우스 우클릭 후 Run으로 실행



변수와 자료형

변수 - 

1. 컴퓨터는 데이터를 어떻ㄱ게 표현할까?
반도체
  - 데이터를 전기 신호로 표현
  - 1, 0 -> 2진수
  - 10진수


2. 10진수와 2진수

16진수 FF (0~9, A,B,C,D,E,F
10진수 - 255
2진수 - 11111111



3. 부호있는 수를 표현하는 방법

1,0 -> 1비트 :0, 1로 표현하는 최소 자리

1바이트 = 1비트 x 8

음수, 양수

7bit -> 숫자 표현
1bit -> 부호비트(음수, 양수)

1바이트 -> 2^7 ~ 2^7 - 1
	  (-128 ~ 127)


자바란?
C,C++ : 플랫폼마다 컴파일을 다르게 하고, 소스 호환성도 플랫폼마다 다르다.

Write Once, Run EveryWhere.

컴파일 -> java -> class(JVM이 해석할 수 있는 중간 언어 컴파일 결과물)
JVM(Java Virtual Machine) -> 자바 가상 머신
class -> 플랫폼에 맞는 형태로 바이너리 코드 컴파일 -> 실행






변수란 무엇일까?
변수 - 바구니
      - 변하는 수
      - 공간의 이름
      - 공간 == 메모리
      - 메모리 공간의 이름


1. 변수 선언하고 값 대입하기

자료형 변수명;  - 변수 선언
자료형 -> 공간의 크기

자료형 변수명 = 값;  - 변수 대입, 변수에 값을 저장




2. 변수 초기화하기

변수에 값을 최초로 대입 -> 초기화



3. 변수 이름 정하기
공간의 이름 - 규칙
1) 알파벳 (대소문자), 숫자, 특수문자( _, $)
2) 숫자는 앞글자로 올수 없다.
3) 예약어는 사용 불가


num1(O)
$num(O)
_num(O)
no-of-student(X)
1st(X)

변수명 관례
- 의미가 있는 명칭

int a - 10;
int noOfStudent;

- 단어의 첫글자는 대문자, 첫 단어만 소문자를 사용합니다.
  no Of Student


변수가 저장되는 공간의 특성, 자료형

1. 변수와 메모리
자료형
  - 기본 자료형
    공간(메모리)의 크기가 결정되어 있는 자료형

  - 참조 자료형

2. 기본 자료형의 종류
  숫자(정수, 실수), 문자

정수형
  1byte -> byte
  (8bit -- 2^7 ~ 2^ -1)

  2byte -> short
  (16bit -> -2^15 ~ 2^25 -1)

  4byte -> int
  (32bit -> -2^31 ~ 2^31 -1)

  8byte -> long
  (64bit -> -2^63 ~ 2^63 -1_


실수형 : 소수점이 있는 수
  4byte - float
  8byte - double

문자형
  2byte - char

논리형 : 참, 거짓 - true, false
  1byte - boolean






=========================================================================

2023.02.23

16일차



변수와 자료형
변수?
공간(메모리)의 이름


1. 자료형 ★★★
    - 기본자료형
      - 메모리의 크기가 정해져 있는 자료형
        정수형
          byte(1) -> -128~127
                  unsigned -> 양의 정부
                  0~255
          short(2)
          int(4)
          long(8)

        실수형
          float(4)
          double(8)
        
        문자형
          char(2)
            값에 '값'
            문자1개

            컴퓨터는 문자 자체는 인식x
            문자 - 숫자 매칭되는 표준안
            ASC|| 코드
            0~255 - 알파벳, 특수문자(1byte)

            문자형이 2바이트 -> 한글 또는 다른 다국어를 표현

            한글 -> 숫자
            UNICODE(유티코드) -> 2바이트 형태의 숫자
            EUC-KR(2)
            U

        논리형
          boolean(1)
            true, false


    - 참조자료형


2. 상수와 리터럴
변수 : 변하는 수, 값 변경 가능

상수 : 변하지 않는 수, 값 변경 불가능
final 변수 -> 상수

final : 마지막, 최종적

long : int -> long
      처음부터 long 범위로 인식(L, l)


double(8) : 소수점 기준으로 double이 기준이됨
float(4) : 처음부터 float 범위로 인식(F, f)
float num = 10.234 -> double num -> float num;


가장 효율적인 자료형
int, double


재료가 되는 값 -> 리터럴 상수
(숫자, 문자, true, false)



3. 형변환
- 묵시적 형변환
  - 작은 자료형 -> 큰 자료형으로 변환

0~1 -> 무한대

- 실수의 숫자 표현범위 > 정수의 숫자 표현범위
- 실수는 정수보다 더 정밀한 수
- 모든 실수는 정수를 포함한다.

정수 -> 실수

byte -> short -> int -> long -> float -> double : 묵시적 형변환

작은 자료형 -> 큰 자료형
덜 정밀한 자료형(정수) -> 더 정밀한 자료형(실수)

연산중에 묵시적 형변환
(작은 자료형-> 큰 자료형, 정수 -> 실수)





- 명시적 형변환
큰 자료형 -> 작은 자료형 : 자료 유실 가능성 O -> 자바쪽에서 의사 표현
                              (자료형)

실수 -> 정수 : 자료 유실 가능성(소수점)

3.14 -> 3



--------------------------------------

주석(설명)
// 한줄설명

/*
  여러줄 설명
*/

- 주석은 컴파일시 배제
- 프로그램 소스 실행 배제

연산자

1. 항과 연산자

10 + 20
항 : 연산에 사용되는 값 10, 20
    값1 -> 단항
    값2 -> 이항
    값3 -> 삼항

  연산자 : 연산에 사용되는 기호(+)




2. 대입 연산자

= 
변수 = 값; -> 왼쪽에 있는 변수 공간에 값을 저장한다.
적용 우선순위가 가장 낮은 연산자.

  int num1 = 10;
  int num2 = 20;
  int result = num1 + num2;

  System.out.println(result);






3. 부호 연산자

+, -

-(부호 반전)
  음수 -> 양수
  양수 -> 음수



4. 산술 연산자

+, -, *, /, %(나머지 연산자)

10 + 2 * 10 -> 30

*, /, % > +, -

(...) -> 가장 높은 적용 우선순위

홀수 
1,3,5,7,9,...
2n + 1


짝수
2,4,6,8,10,...
2n




5. 증가감소 연산자
  1씩 증가, 1씩 감소

  ++
  num++ -> num = num + 1;
  ++num -> num = num + 1;

  --
  num-- -> num = num - 1;
  --num -> num = num - 1;




6. 관계(비교) 연산자

  >, <, >=, <=, ==(같다), !=(다르다)

  연산의 결과 -> 논리값(true, false)

int num = 10;
boolean result = num > 5;
System.out.println(result);





7. 논리 연산자

  AND -교집합 - &&
      두 항이 모두 참일때 -> 참
      true && true -> true

  OR - 합집합 - ||
      두 항중에서 한개라도 참 -> 참
      true || false -> true
      false || true -> true

  NOT - 부정 -!
      참 -> 거짓
      거짓 -> 참

  연산의 결과 : 논리값(true, false)

  논리 연산자 < 비교 연산자






8. 복합 대입 연산자(단항)

  산술연산자(+,-,*,/) + 대입(=)

  num += 2; // num = num + 2;
  num *= 2; // num = num * 2;





9. 삼항조건 연산자

  1       2         3
조건식 ? 참일때 : 거짓일때

문자가 여러개 -> 문자열

A : 문자 char ch = 'A'
ABC : 문자열
String str = "ABC";


+ : 문자열 결합 연산자
"ABC" + "DEF" => "ABCDEF";





10. 연산자 우선순위

(..), [..] > 단항  ... > 비교 > 논리 > ... > 대입(=)





-------------------------------------


조건문



선택문
switch(키워드){
  case 값1:
    // 값1에 매칭 되었을때 실행되는 영역

  case 값2:
    // 값2에 매칭 되었을때 실행되는 영역

}

ENUM 상수
문자열





반복문

- while문

while(조건식){
  // 조건식이 참일때 반복되는 코드
}



- do ~ while문

do {
  // 조건식이 참일때 반복되는 코드
} while(조건식);




- for문
횟수가 정해진 반복문에 유용

for (초기화식; 조건식; 증감식){

}

반복 횟수, 순서(1,2,3,4, ...) -> 인덱스(index)

초기화식 변수명 -> int i(관례적)

break -> 반복 중단\

continue -> 건너뛰기 : 현재 반복을 중단하고 새로 시작




중첩 반복문

  반복문 안에 반복문
  for -> for
  for -> while
  while -> for
  while -> while

  중첩 반복에서 초기화 변수값
  i -> j -> k -> l ....




=======================================================================

2023.02.24

17일차



배열 
많은 변수를 한꺼번에 선언


1. 자료를 순차적으로 관리하는 구조, 배열
  동일 자료형, 순자적으로 나열(메모리) ★★★

  0 1 2 3 4
  ㅁㅁㅁㅁㅁ

  같은 자료형 + 물리적으로 나열된 구조 -> 순서 유무가 매우 쉽다.

  순서가 중요(0,1,2,3,... - 인덱스)
  [순서 인덱스] -> 인덱스 연산자([])



2. 배열 선언과 초기화

자료형[] 배열변수명 = new 자료형[갯수];  -> 더 많이 사용

자료형 배열변수명[] = new 자료형[갯수];

배열 선언 + 초기화
자료형[] 배열변수명 = new 자료형[] {값1, 값2, 값3 ...}
                      ↓
자료형[] 배열변수명 = {값1, 값2, 값3 ...}


기본 변수
  정수 : byte, short, int, long
    -선언만 하면 0

  실수 : float, double
    - 선언만 하면 0.0

  문자 : char

  논리값 :boolean
    - 선언만 하면 false


참조자료형 변수
  - 선언만 하면 null





3. 배열 사용하기
모든 배열 -> length 속성
length : 공간의 갯수


향상된 for : 처음부터 끝까지 반복

for(자료형 변수 : 배열 변수){

}





4. 다차원배열

자료형[] 배열변수명 = new 자료형[갯수];   -> 1차원 배열 
  - ㅁㅁㅁㅁ(직선)


자료형[][] 배열변수명 = new 자료형[행갯수][열갯수];  -> 2차원 배열
  - 평면
  int[][] nums = new int[2][3];   //2행 3열 

  자료형[][] 변수명 = new 자료형[][]{{값1, 값2, 값3 ...},{값1, 값2, 값3 ...} ...}


자료형[][][] 배열변수명 = new 자료형[높이][가로][세로]   -> 3차원 배열
  - 입체
    가로 세로 높이






연산자 오버로드
+
문자열 + 문자열 -> 문자열 결합

new 연산자
-> 객체 생성

배열에서 new 연산자
-> 갯수 만큼 변수 공간 생성




---------------------------------------


객체 지향 프로그래밍 1

객체란?
Object - 사물, 대상

회원
상품   
주문 - 회원이 상품을 구매하고자 주문을 할때
-> 상호작용이 중요하다


1. 객체와 객체지향 프로그래밍

속성 - 변수

행위 - 함수

객체간의 상호작용(중요) ★★★



2. 클래스 살펴보기 (객체x, 설계도o)
- 객체를 만들기 위한 설계도

class 클래스명{
  멤버 변수 정의

  멤버 함수(메서드) 정의
}


클래스 자료형 변수 = new 클래스명();  -> 객체 생성

멤버 변수
멤버 함수(메서드)

변수.변수명
변수.함수(...);


설계도 Class -> 메모리라는 부품 -> 객체(Object)

객체 == 인스턴스(instance - 실체: 실제로 존재한다.)




3. 클래스 이름을 짓는 규칙
관례
  - 단어의 첫 글자를 대문자 : 파스칼 케이스
  예) OrderInfo - Order Info



4. 클래스와 인스턴스


5. 패키지란
package -> 폴더

java.util
java.time

import exam03.*;   -> 특정 패키지의 내용을 불러온다.


※ 변수는 메모리 공간으로 값을 저장하기 위해서는 메모리가 존재해야 한다.
객체는 사물이나 대상을 뜻하며 클래스는 객체를 설계하기 위한 설계도이다.


메서드
1. 함수란
2. 함수의 입력과 반환
3. 함수 정의하기

  반환자료형 함수명(매개변수1, 매개변수2, ...){
    //기능이 수행되는 코드

    return 수행결과의 반환값;
  }

  함수이름(값, ...);  -> 실행

  참조변수명.함수이름(...);


- 함수 이름
- 매개변수
- return 예약어와 반환형

4. 함수 호출하고 값 반환하기
5. 매개변수 살펴보기
6. 함수 호출과 스택 메모리

스택 영역 메모리 -> 함수가 연산을 위해 필요한 메모리 할당

자료구조
스택(Stack) 구조 - 쌓다 

큐(Quesue) 구조 - 일렬로 대기

[함수] 지역 변수

main() -> add()




===================================================================


2023.02.27

19일차



자바 API 문서 다운로드
jdk downlord

메서드



1. 함수란?
- 기능을 수행하는 코드

2. 함수의 입력과 반환

3. 함수 정의하기

4. 함수 호출하고 값 반환하기
함수명(매개변수 ...);

5. 매개변수 살펴보기



6. 함수 호출과 스택 메모리

1) 함수의 반환값 없을수도 있다.
  - void

2) 매개변수가 없는 함수도 있다.

함수명을 짓기 규칙
1. 알파벳, 숫자, 특수문자( _ , $)
2. 숫자는 가장 처음에 정의할수 없다.
3. 예약어 x

권장사항(관례)
1) 의미가 있는 명칭
2) 카멜 케이스 형태

 getMembers



7. 함수의 장점
1) 코드 중복 방지 -> 효율성
2) 유지보수에도 유리

함수의 시그니쳐 -> 실제 함수를 구분하는 이름
반환값 타입 + 함수명 + 매개변수

함수는 중복 정의 x -> 



8. 클래스 기능을 구현하는 메서드



자바의 이름짓기 규약
- 클래스 이름
    - 파스칼케이스(단어 첫문자 -> 대문자)
    - Orderlnfo

- 메서드 및 멤버변수(단어 첫문자 -> 소문자)
    - 카멜케이스
    - noOfStudent
    - gerMembers

- 패키지 이름
    - 소문자 형태
    
- 상수명
    final 변수
    대문자
    단어와 단어 사이 _
    MAX_NUM



클래스와 인스턴스 

1. 클래스 사용과 main(), 함수




2. new 예약어로 클래스 생성하기

변수 정의 -> new -> 변수(힙)

== (주소값의 비교)


3. 인스턴스와 참조 변수

4. 참조변수와 참조



----------------------------------------

데이터 영역(코드 & 상수 영역)
- 컴파일된 class 파일 -> 클래스 로더 -> 데이터 영역 코드 영역에 구조화

생성자
- 객체를 생성해주는 함수
- 클래스 정의 -> 필요한 자원 -> 메모리
- 생성자 함수의 호출 결과로써 객체에 접급할 수 있는 주소값을 반환
- 클래스명과 동일한 함수명
- 기본 기능 : 객체 생성기능 -> 숨겨져 있다.
- 소스에서 통제 불가


1. 디폴트 생성자
  - 클래스 안에 생성자 메서드가 정의되어 있지 않은 경우
  - 컴파일러가 자동 생성해주는 생성자 메서드
  public 클래스명( ){ }

2. 생성자 만들기
3. 생성자 오버로드
4. 참조 자료형


-------------------------------------------

정보 은닉 

1. 접근 제어자(클래스, 변수, 메서드) ★★★
    public : 접근 범위가 클래스, 내부 외부, 타(외부) 패키지까지 접근
    protected : 동일 패키지에서 클래스 내부, 외부에서 접근 가능(default)
		- 타(외부) 패키지에서는 상속을 통해서 클래스 내부에서 접근 가능(private)
    default : 접근 제어자를 따로 정의 안한 경우
 	  : 동일 패키지에서만 클래스 내부, 외부에서 접근
    private : 클래스 내부에서만 접근이 가능




단축키
Alt + 엔터 : import 키

==========================================================================

2023.02.28

20일차



2. 멤버 변수 -> private 
- 멤버 변수는 값을 대입할때 값이 설정
- 멤버 변수는 값의 통제가 불가
- 접근 못하게 private으로 막아준다.

* 멤버변수 -> 값을 통제할수 없다 -> 



3. 멤버변수의 값을 지정하고, 조회할 수 있는 메서드 추가
getter, setter -> 멤버변수를 지정하고 조회할 수 있는 별도 메서드 정의

Object : toString() 재정의 : 멤버 변수의 값을 확인
객체의 참조변수를 출력 -> toString() 호출




this 예약어 -> 지역변수로 모든 메서드에 추가

지역변수
  - 모든 인스턴스 메서드의 지역변수
  - 생성될 객체(인스턴스) 주소를 가지고 있는 참조변수

생성자 메서드
  this()


--------------------------------------------


static 변수

1. static?
static 정적인 : 고정된
  -> 동적인

정적 메모리 - 한번만들어지면 애플리케이션이 끝날때까지...
  - 데이터 영역

동적 메모리 - 메모리가 빠르게 채워지고 지워지는 ...
  - 스택, 힙 영역



2. 클래스 변수(static 변수)


3. 클래스 메서드(static 메서드)
객체 생성과 관련X
지역변수 this는 없다.  -> 인스턴스 자원 접근 불가(인스턴스 메서드, 인스턴스 변수)


변수의 유효범위

▶지역변수 : 함수가 호출될때 스택에서 활성화되고 종료되면 제거되는 변수
(함수가 실행되는 동안만 유지)

▶인스턴스 변수 : 객체가 생성되면 힙에서 공간을 할당
(참조가 끊기면 가비지 콜렉터(GC)가 해제)

▶정적변수 : 클래스로더 -> 클래스 구조화시 -> 활성화되면 변수
	-> 객체 생성과 관련X
	-> 데이터 영역


객체 생성 상관없이 기능적인 부분을 공유
java.lang.Matrh




static 응용- 싱클톤 패턴

- 인스턴스를 1개만 생성해서 공유
- 기능을 담당하는 클래스는 객체를 여러개 만들 필요 X

1. 생성자 메서드에 접근 제어자를 private : 외부 생성 차단
2. 객체를 클래스 내부에서 생성한다.
3. 내부에서 생성된 객체를 외부에서 사용할 수 있는 메서드
   (static Calcu

-------------------------------------------


===============================================================

2023.03.02

21일차

상속과 다향성
1. 상속이란?


2. 클래스의 상속
class 하위클래스 extends 상위클래스 {
	...
}



3. 클래스 상속 문법

A <-- B <-- C

컴파일러가 모든 생성자 메서드의 첫번째 라인 
super();   // 상위클래스 기본 생성자



4. super (= this와 동일) - 생성자의 주소를 가지고 있는것

  지역변수 : 상위 클래스의 생성될 객체의 주소 값을 가지고 있는 참조변수

  메서드 : 상위 클래스의 생성자 메서드

1                2                     3
C() -> super() : B() -> super() -> A()



5. 상속에서 클래스 생성과 형 변환 (예 - 오렌지주스)

- 묵시적 형변환(다형성)
  -> 하위클래스가 상위클래스의 자료형으로 형변환

- 명시적 형변환(확인)
  -> 상위클래스에서 하위클래스로 형변환 자동 X
  -> 이유 : 상위클래스 객체의 출처가 하위클래스가 아닐수도 있기때문에.




6. 다운 캐스팅과 instanceof
참조변수 instanceOf 클래스
-> 참조변수가 참조하는 객체가 클래스로 부터 유래된 객체인지..

상위클래스 인스턴스 < 하위클래스 인스턴스

  일반적인 개념              구체적인 개념

    사람                        
    강아지 
    호랑이 
    새




7. 메서드 오버라이딩(재정의)
하위클래스가 상위클래스의 메서드와 동일한 명칭으로 정의
-> 하위클래스의 메서드가 우선적으로 실행

애노테이션(Annotation)
@...
- 설명, 주석
-> 프로그램 내에서 참고하는 설명



8. 가상 클래스



-----------------------------------------------

2023.03.03

22일차



추상 클래스
추상적(정해지지 않은) <---> 구체적(정해져 있는)

구체적 클래스는 변수와 메서드가 정해져 있다.

==>클래스에는 변수와 메서드가 정해져있다. 추상클래스는 메서드에만 관심이 있다. 
클래스
  변수
  메서드



1. 추상클래스란?

구현체가 없는 메서드를 포함하는 클래스(메서드에만 관심있음)


2. 추상클래스 문법

메서드의 앞에 abstract
클래스 앞에 abstract

public class Calculator {
    public int add(int num1, int num2);  //이렇게만 쓰면 오류가 난다.
}
                              ↓

public abstract class Calcualtor {  //계산기
    public abstract int add(int num1, int num2);   //추상클래스 -> {}가 구현체를 의미
}



InputStream

추상메서드(설계)
공통기능



3. 추상클래스와 다형성



--------------------------------------

* 자바에서의 상속
상속 extends
- 단일 클래스 상속만 가능하다.

---------------------------------------


final 예약어
  - 변경 불가

1. 변수 - 상수

2. 메서드 - final이 앞에 붙어 있으면 재정의가 불가능하다.

3. 클래스 - 클래스 자체는 변경이 안되니 상속을 통해서 확장을 해야하는데 final이 있으면 상속이 불가능하다.



-------------------------------------


인터페이스
- 설계용으로 용도가 정해진 클래스의 일종(설계만 관심있는 클래스 - 추상메서드만 정의 가능)

class -> interface


1. 구현 코드가 없는 인터페이스

implements(구현하다)


2. 인터페이스 구현과 형변환(다형성)

3. 인터페이스의 요소 살펴보기

private -> JDK9 / JDK12버전에서 사용가능
private은 default 안에서만 사용이 가능하다.



다중 상속



인터페이스간 상속 - extends



-------------------------------------

내부 클래스
  - 클래스 내우에서 정의된 클래스

1. 인스턴스 내부 클래스
  - 인스턴스 자원과 비슷한 성격(변수, 메서드)
  - 외부 클래스의 객체 생성 후 객체 생성 가능
  - 정적 자원 정의 불가(JDK15)
  - 정적 자원 정의 가능(JDK16 이후부터)


2. 정적 내부 클래스
  - 정적 자원과 비슷한 성격(정적 변수, 정적 메서드)
  - 외부 클래스의 객체 생성과 상관없이 사용 가능


3. 지역 내부 클래스
  - 함수 내부에서 정의하거나 사용하는것
  - 인터페이스, 추상클래스 -> 객체 생성이 가능
	- 환경 : 지역내부(함수), 멤버 변수
	- 미구현된 메서드를 구현함으로써 

4. 익명 내부 클래스




인스턴스 자원과 정적 자원의 차이점 
-인스턴스
-정적


======================================================


2023.03.06

23일차

예외처리
1. 오류와 예외

-시스템 오류(error)
  - 서버, JVM, 시스템 에러
  - 개발자가 통제 x



-예외(exception)
  - 프로그램 소스상에서 발생하는 오류(예외)
  - 개발자가 통제 o (처리가능)

  - 예외체크가 컴파일시에 진행

Throwable(모든 error의 상위 클래스)
  Excetion
    - IOExcetion
- FileNotFoundException
    - NullPointExcetion

    - 컴파일시에 예외가 체크
    - 예외 발생시 -> 컴파일 x(class 파일 x)
    - 엄격한 예외
    - 예외가 발생하든 안하든 반드시 적절한 예외처리가 필수
    

Throwable
    Excetion
   RuntiomeException
         - ArithemathicExcetion

    - 실행중에 예외가 체크
    - 컴파일은 된다. (class 파일 o)
    - 비교적 유연한 예외


2. 예외 클래스의 종류



3. 예외 처리하기

1) try ~ catch문


예외가 발생한 객체를 던져서 catch(잡는다) 한다.
try{
  // 예외가 발생할 가능성이 있는 코드
  // 예외가 발생하는 코드
  // throw 예외 객체
} catch (예외 객체){
  // 예외가 발생하면 유입되는 구간 - 예외에 대한 적절한 처리
}

2)try ~catch~ finally문

finally -> 예외가 발생하든 안하든 항상 실행되는 영역

- 예) 실행 로그




3)try ~with~resources문(1.7에 추가된 기능)

 - try ~catch에서 자동 리소스 해제

try (작업이 종료되면 해제할 리소스){
  //오류가 발생할 가능성이 있는 코드
} catch(...){

}






4. 예외처리 미루기

5. 다중 예외 처리
IOException
NullPointException

catch 구간 -> 여러개 정의

catch(예외클래스 | 예외클래스)
















