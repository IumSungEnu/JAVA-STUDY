Spring Data JPA
1. JAP 동작방식
spring data jpa - starter

ddl-auto
  create : 모든 테이블을 삭제(DROP)하고 다시 생성 -> 개발 초기
  update : 테이블을 삭제하지 않고 변경된 항목만 테이블에 추가, 변경 -> 개발 중기
  validate : 테이블의 차이점을 검증, 생성, 변경x -> 테스트, 배포시
  none : 아무것도 하지 않는다. -> 배포 서버


JPA(Java Persistence API) - 상태변환
자바 영속성 API
구현체 : Hibernate Entity Manager

Persistence(영속성) : 엔티티의 상태 변화 감지 메모리

EntityManagerFactory : EntityManager를 생성
EntityManager : 영속성 관리자


영속성에 엔티티의 상태 감지 -> 쿼리 실행

EntityManager : 영속성 관리 메서드
  persist(엔티티) : 엔티티를 영속 상태로 만드는 메서드
		(상태 감지)
  flush() : 영속성의 상태 변경 상태 -> DB에 반영
  remove() : 영속성의 제거 상태 변경(영속성 분리가 아니라 제거상태)
	-> flush()가 되면 DELETE 쿼리가 실행된다.
  find() : 조회
	-> 영속 상태가 아니면 DB에서 조회 -> 영속상태 -> 조회
	-> 영속 상태일 경우 -> 조회(캐시의 이점)
  detach : 영속 상태 분리
	- 상태변화를 감지하지 않는다.
  merge : 영속 상태 분리된 엔티티를 다시 영속상태로 만드는 것
	- 상대변화를 감지한다.


데이터 추가, 수정, 삭제 : O
조회 - 사용시 제한이 있다.

JPQL - Java Persistence Query Language


2. Entity 설계하기

3. Repository 설계하기
  JpaRepository 인터페이스 상속 -> 구현체를 Proxy 형태로 자동 생성

  엔티티 save(엔티티)
  .... savaAndFlush(...)
  saveAll
  saveAllAndFlush(...)

  findAll
  findOne

  count() : 전체 갯수
  delete(엔티티) : 영속성 제거
  flush()






4. 쿼리 메서드

Pageable 인터페이스 
  - 페이징

spring data doc api

PageRequest.of(int page, int size)
	- page : 페이지 번호(0부터 시작)
	- size : 추출 갯수


**JPQL 보기**(과제)




5. @Query 애노테이션

6. Querydsl

querydsl-jpa
querydsl-apt : 쿼리빌즈가 설치된 클래스가 자동생성

plugin - 백그라운드 프로그램
apt-maven-plugin : 감지할수 있게....

javax
jakarta


BooleanBuilder - Predicate의 구현체
- WHERE 조건

Q엔티티 


반드시 기억해주세요★★★
쿼리 DSL, Reponsitory 인터페이스 상속에 QuerydslPredicateExecutor가 추가

It -> Iesser than <
le -> lessen than equal <=
gt -> greater than >
goe -> greater than equal >= 
like
desc
asc







7. 연관관계 매핑
@ManyToOne : 다대일 매핑
- 게시글에서
  게시글(BoardData) - Many
    - One쪽의 외래키(Member : userNo)

  회원(Member) - One


@OneToMany : 일대 다 매핑
- 회원쪽에서 
  회원(Member) - One
  게시글(BoardData) - Many

  - 연관관계의 주인 설정
    - 관계의 변경이 가능한 쪽이 주인

@OneToOne : 일대일 매핑






8. 영속성 전이
-db가 아닌 영속성 안에서 직접 영속성 전이를 한다.







9. 지연로딩
@ManyToOne(가장 많이 사용)
  - fatch
      FetchType.EAGER : 즉시 로딩 전략
	- 처음부터 join
	- 테이블 조인이 많으면 로딩이 느려진다(성능 저하)
      
      FetchType.LAZY : 지연 로딩 전략
	- 처음에는 엔티티 데이터만 조회
	  - 연관 매핑되어 있는 컬럼을 getter로 조회
	  -> 쿼리 실행

	- 조인이 많이 필요한 엔티티에서 성능 향샹
	- 문제는 목록 형태의 데이터 조회시 1+N 문제가 발생
	  - 필요한 경우에만 즉시 로딩 전략
	  - jpql : fetch join

@OneToMany
  - fatch





10. Auditing을 이용한 공통 속성화
- 엔티티의 상태 변환에 따라서 값이 변경
  @CreatedDate
  @LastModifiedDate

- 이벤트 감지
  @EntityListeners(AuditingEntityListener.class)

- 활성화(설정 클래스)
  @EnableJpaAuditiog





- 데이터베이스에 추가될 때 값이 변경
  @CreationTimestamp
  @UpdateTimestamp

참고)
@Column
  updatable = true
  insertable = true

Member -> BoardData -> Member -> BoardData -> Member

순환참조(메모리 오류
(lombok toString 메서드는 getter를 통해서 값을 조회)







11. @IdClass
  - 기본키를 여러개 조합해서  사용

분류테이블
분류, 서브분류















