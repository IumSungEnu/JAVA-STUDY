
2023.03.21


평가안내
4/3(월) - 2~4교시(실제 구현)

개발환경 구축
1. maven 설치 및 설정
  - 프로젝트 의존성 관리+빌드 툴(배포, 테스트, 프로젝트 생성)

apache maven검색 -> 다운로드 -> 저장할 파일에 압축출기 -> bin -> 전체경로 url 복사

C:\Users\Administrator\Desktop\임성은\apache-maven-3.9.1\bin

시스템 환경변수 편집 -> 환경변수 -> 시스템 변수(path) 선택후 편집 -> 새로 만들기 -> 복사한 url붙여넣기
 -> 확인 -> 확인


자바버전 확인
cmd -> java -varsion입력후 자바 버전 확인 -> 로컬 c -> Program Files -> java -> jbk-11(일경우) -> 경로복사

C:\Program Files\Java\jdk-11

시스템 환경변수 편집 -> 환경변수 -> 시스템변수 -> 새로만들기 -> JAVA_HOME(저장경로) -> 확인
-> cmd -> mvn -v 입력





war : 웹 배포파일
jar : 


-------------------------------------------------------------

2. smart tomcat 설치 및 톰갯 연동

tomcat9 download 검색 -> 홈페이지 하단이동 -> 64-bit Windows 설치

파일 -> 설정 -> Plugins -> Smart tomcat 설치 -> ok 
Run -> Edit Comfigurations -> Add new -> Smart tomcat 클릭 -> Name:tomcat9 작성 -> 
tomcat server에 파일경로 지정 -> Server port는 3000으로 지정했는데 굳이 안해도 된다. -> ok


localhost -> 웹 서버에서 직접 접근
127.0.0.1

3000 - 포트 : 데이터 이동 통로
http - 80 / https - 443

주소:포트번호


javaee8
- javax.

jakarta9,10
- jakarta.


-------------------------------------------------------------


3. maven 사용방법 익히기

mvn

프로젝트 생성
mvn archetype:generate

배포 파일 생성 - war, jar
mvn package
-> mvn clean :기존 컴파일된 파일을 삭제 -> 패키징
-> 컴파일 -> 테스트 -> 배포파일 생성

테스트 수행
mvn test

컴파일
mvn compile -> 빌드(클래스 파일 다시 생성)

컴파일 파일 삭제
mvn clean

gradle 


설치된 의존 라이브러리(공유)
사용자/.m2/repository



mvnrepository 사이트


--------------------------------------------------------------

4. lombok 설치 및 설정 -> getter, setter와 작별
파일 -> 설정 ->

mvnrepository 사이트 -> Lombok검색 -> Project Lombok클릭 -> 최신버전 클릭 -> Maven 전체 복사
-> pom.xml에서 <dependencies>안에 붙여넣기

자바버전 수정 -> pom.xml에 추가
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>19</maven.compiler.source>
    <maven.compiler.target>19</maven.compiler.target>
</properties>


@Getter
@Setter
@ToString
@Builder : 빌더 패턴 자동 생성
@AllArgsConstructor :모든 멤버 변수 초기화 생성자
@NoArgsConstructor :기본 생성자
@RequiredArgsConstructor : -> 상수로 정의된 멤버변수, 값이 없는 경우
  private final 자료형 변수명; -> 상수의 초기화 기능이 추가
    


------------------------------------------------------------

TDD
단위테스트(unit test)
1. junit5

jupiter api junit -> 첫번째 클릭 -> 5.9.2 클릭 -> 전체복사 pom.xml에 <dependencies>안에 붙여넣기
-> 다시 jupiter api junit에서 4번째 클릭 -> 5.9.2 클릭 전체복사 pom.xml에 <dependencies>안에 붙여넣기


maven surefire -> 첫번째 -> 3.0.0 클릭 -> 
<artifactId>maven-surefire-plugin</artifactId>
<version>3.0.0</version> 2개만 복사해서 pom.xml에 붙여넣기



  assertEquals(expected, actual)
    -> toString(), 값

  assertSame (Object expected, Object actual)
    -> 객체의 물리적 주소가 같은지 비교(동일객체 여부)

  fail() -> 임의의 테스트 실패

  assertThrows(Class<T> expectedType, Executable executable)
    -> 어떤 실행 -> 예외발생하면 테스트 성공

  assertDoesNotThrow(Executable executable)
    -> executable을 실행한 결과로 익셉션이 발생하지 않는지 검사한다.


회원가입
    테스트 -> 기능(TDD)
    1) 쉬운 테스트 -> 복잡한 테스트

  @DisplayName("문구") -> 테스트 명칭

    Service

Validator
  - 필수 항목으로 자리수를 체크합니다.




-----------------------------------------------------



2023.03.22

1. @Test
2. 주요 단언 메서드

3.테스트 라이프사이클
1) @BeforeEach
  - 테스트 케이스 실행 전에 
  - 테스트 케이스 실행전 사전 작업이 필요

2) @ArferEach
  -테스트 케이스 실행 후에
  - 테스트 케이스 실행 후 정리 작업이 필요

3) @BeforeAll
  - 모든 테스트 실행 전 가장 처음 실행
  - static  메서드로만 정의

4) @AfterAll
  - 모든 테스트 실행 후 가장 마지막에 실행
  - static 메서드로만 정의



4. 추가 애노테이션
1) @DisplayName
2) @Disable
     -> 테스트 배제
3) @TempDir
     -> 임시 폴더를 생성
4) @Timeout
     -> 성능체크
     -> 지정된 시간내에 기능 수행이 되는지




2. mockito 기초 사용법
1. 모의객체 생성()





- 반환값이 있는 경우
given( 객체.메서드)
  .willReturn
  .willThrow

- 반환값이 없는 경우
  willThrow(발생할 예외 class)
     .given(모의객체)
     .호출메서드



---------------------------------------------------






행위테스트

웹기초
▶요청 - 브라우저에서 주소를 입력하면(Request)
형식 : 요청 전문 형식을 가지고 서버에 요청
  요청 헤더(header) - 요청쪽의 정보★★★
    - 요청 방법(method)
	-GET, POST
    - 요청 IP, 주소가 담겨있다.
    - 요청 환경에 대한 정보
	- 언어, 국가
	- 사용하는 브라우저 종류
	  (user-agent)
    - 요청 바디의 데이터 종류
	(content - type) - POST 바디 데이터의 형식
	-> application/x-www-form-urlencoded

  요청 바디(body) - 요청 데이터
      - POST 요청 데이터(application/x-www-form-urlencoded)
          키=값&키=값



▶응답 - 서버에서 응답해준다.(Response)
- Server
    Servant - 서비스를 제공한다.
형식 : 응답 전문 형식을 가지고 브라우저에 응답
  응답 헤더(header)
    -  응답 상태 코드
	2xx   --> 서버를 거쳐서 응답
	  - 200(가장 많이 보는 것) : 응답 성공 (요청 -> 서버 -> 응답)
	  - 201 : 작성됨(POST -데이터 쓰기, 수정, ...)

	3xx
	  - 301, 302 : 페이지 이동
 	  - 304 -> 캐시됨(캐시 - 브라우저 파일 임시 저장)★★★
		  -> 요청 -> 캐시o -> 사용
                 //스타일 시트가 안바뀐다, 이미지가 안바뀐다 -> 304번인지 확인(캐시 사용 중지 체크유무)
                 //서버가 부담스러워하기 때문에 임시 저장을 해준다.

	4xx  --> 요청측의 문제
	  - 400 : Bad Request : 잘못된 요청(개발자할때 많이 보게된다)
		- 요청 데이터가 잘못되었을때
	  - 401 : 접속 권한 없음(관리자 페이지에 주로 사용) - unauthorized
	  - 403 : forbidden :특정 폴더의 접속권한이 없을때
	  - 404 : 제일 많이 보게될 오류 : Not Found(낫파운드) : 페이지 없음
	  - 405 : Not Allowed Method(GET, POST ...) : POST만 허용하고 있는 URL, GET방식 접근
	    예) POST 타입으로 개발했는데 GET을 요청했을 경우

	5xx   --> 서버쪽 오류
	  - 500 : 서버 내부 오류
 		- 실제 서버 장비에 문제가 있는경우
		- 프로그램 소스의 오류
	  - 501,502 : Service Not Available, Maintainance... : 서버를 임시로 닫는다.(점검)

    - 응답 바디에 데이터의 종류
        (content - type) 
	예) test/html

    - 서버의 브라우저 행위(기능) 통제
        1) Location: 주소 -> 브라우저에게 주소 이동
        2) Refresh : 초; -> 설정된 초 단위(주기)로 새로고침
        3) Cache-Control : ...
        4) Set-Cookie: 키 = 값; .... -> 브라우저에 쿠키 저장
        5) content-disposition: attachment; filename = 파일명 
	-> 바디 데이터를 파일명으로 작성하여 다운로드
        

  응답 바디(body)
    - 응답 데이터 : 서버가 인식하려면 반드시 응답헤더에 content-type이 있어야 한다.
    예) HTML 문자열






요청방식( method) - 대표적으로 GET,POST
▶GET - 조회 목적
- 브라우저 주소창에 입력하고 요청

https://search.naver.com/search.naver
?   (궁금하다)
where=nexearch(항목 = 값)
&
sm=top_hty(항목 = 값)
&
fbm=1(항목 = 값)
&
ie=utf8(항목 = 값)
&
query=블로그   -> 검색한 키워드
(항목 = 값)


?where=nexearch&sm=top_hty&fbm=1&ie=utf8&query=블로그
--> 쿼리 스트림

질의(query) - 이러이러한 것을 찾아줘..


 - 바디에 데이터는 없다, 헤더 정보만 전달







▶POST - 데이터 작성, 쓰기 ... 목적
  - 헤더 content-type -> 작성된 body 데이터의 종류(O - 서버가 데이터의 종류를 알수 있어야 데이터를 가공)
  - 데이터가 body에 작성된다

  content-type : application/json
  { "키" : "값", "키" : "값" }





GET - 조회
    DELETE - 삭제(데이터를 조회해야 삭제가 가능)

POST - 작성
    PUT - 데이터의 전체 변경
    PATCH - 부분 변경

OPTIONS 


----------------------------------------------------------

=======================================================================


2023.03.23


서블릿
- 자바의 웹기술

maver
  javax.servlet-api
  javax.servlet-jsp.api

  -> 톰캣 서버에 내장
  -> 배포시에는 필요x, 개발시에만 o



1. HttpServlet : 추상크래스(핵심적 클래스)
  -> 이 클래스를 상속 받으면 서블릿 클래스가 된다.
 web.xml : 서블릿 설정
<?xml version="1.0" encoding="utr-8"?>

xml -> 마크업 언어 일종, 태그 형태로 -> xml -> 설정

/webapp/WEB-INF/web.xml

<scope>provided</scope>

complied - 기본값 : 배포시에 포함
runtime
provided : 배포시에는 제외
  -> servlet-api, servlet.jsp-api -> 플랫폼(tomcat)에 이미 내장
test : 테스트시에만 필요한 라이브러리


HttpServletRequest ★★★
  - 요청과 관련된 정보, 기능

HttpServletResponse ★★★
  - 응답과 관련된 정보, 기능


/hello
/hello/경로
/hello/경로



서블릿 4.0
@WebServlet("경로")



웹서버는 동시에 여러 접속이 이루어지고 동일한 서블릿을 여러 쓰레드가 사용
-> 동시성 문제 발생
-> 서블릿에서는 인스턴스 변수 사용을 자제한다.


서블릿 객체 생성-> init() -> 요청 처리 메서드(doGet, doPOST) -> destory()

init() -> 요청 처리전 초기화(설정 처리)
destroy() ->요청 처리후 처리할 작업(자원 정리)


2. Filter 인터페이스
  - 공통 실행 부분

Filter 걸러준다


호출 순서 (예제)
  helloFilter1 -> FilterChain ... doFilter -> helloFilter2 -> FilterChain ... doFilter -> HelloSerlet::doGet() ...
                       (추상 클래스)

  응답 후 -> helloFilter2 -> helloFilter1


  필터 래퍼
  HttpServletRequest 인터페이스를 기본 구현해 놓은 Wrapper 클래스 : HttpServletRequestWrapper
  HttpServlertResponse 인터페이스를 기본 구현해 놓은 Wrapper 클래스 : HttpServletResponseWrapper

  필터 래퍼 클래스를 상속 받아서 공통기능이나 기본 기능의 수정




JSP의 특징
1. JSP의 페이지 처리과정
  -> 번역
  hello.jsp -> 번역 -> hello_jsp.java (서블릿 클래스) -> hello_jsp.class -> 실행
		      (+ 기능, 확장된 서블릿 형태)



2. JSP 생명주기
①_jspInti() : 초기화

②_jspService(HttpServletRequest request, HttpServletResopnse response);  : 요청 처리 메서드
  - 대부분의 작성 코드가 번역되서 추가되는 영역

③_jspDestroy()



*자바에서 웹 기술은 서블릿이다. jsp를 사용하면 서블릿 클래스로 바뀐다.
jspService()에 리퀘스트, 리스펀스가 있기 때문에 중요하다.


3. 스크립트 태그
JSP 페이지에서 자바 코드
1) 선언문(declaration) - 변수나 메서드 등을 선언하는 태그
번역위치가 클래스명 바로 아래쪽에 위치 
변수 - 멤버변수
<%!
  자바코드
%>

2) 스크립틀릿
_jspService()의 지역 안에 번역
변수 - 지역변수
<%
  자바코드
%>

3) 표현문
_jspService()
<%=변수%> -> 변수의 값을 출력
out.print(변수);-> 내장객체


_jspService() : 내장객체 ★★★(암기)★★★
HttpServletRequest request
HttpServletResponse response
PageContext pageContext : 현재 실행중인 jsp로 번역된 서블릿 객체의 환경관련 정보
HttpSession session : 개인화된 서비스를 구현하기 위한 기술
ServletContext application : 서블릿 환경에 관련된 정보, 메서드가 있는 객체
ServletConfig config : 서블릿 설정관련 객체
JspWriter out : 출력스트림
Object page = this
exception : page 디렉티브 isErrorPage="true"



속성 처리 메서드의 종류

속성을 관리하는 내장 객체
속성 -> EL 변수로 사용가능







hello.jsp -> 번역 -> hello._jsp.java -> hello_jsp.class -> 실행
                         (확장된 서블릿)

_jspInit()
_jspService(HttpSevletRequest request, HttpSevletResponse response) : 요청 처리 메서드
_jspDestroy()





4. 디렉티브 태그
<%@ ... %>

page : JSP 페이지에 대한 정보를 설정
include : JSP 페이지에 다른 jsp, html ...(물리적으로) 포함


  참고)
    <jsp:include ... /> -> 요청 처리시에 처리결과를 버퍼에 추가

taglib : 태그 라이브러리, 커스텀 태그로 사용 설정하기 위해서.
jstl : Jsp Standard Tag Library : 외부에서 제공되는 커스텀 태그




5. JSP의 주석처리
<%-- 주석 --%>



=============================================================

2023.03.27


액션태그
서버나 클라이언트에게 어떤 행동을 하도록 명령하는 태그

<jsp:액션 .../>

<jsp:액션... >

</jsp:액션>


1. forward
  - 페이지 변경(버퍼를 변경함으로써 페이지 변경)
  - 페이지 이동 x (버퍼 변경)
  - <jsp:forward 태그 전에 쌓여있던 버퍼를 비우고
  - <jsp:forward 태그 page에 지정된 파일의 버퍼로 교체

  참고)
    응답 헤더에 Lovation:주소
    -> 브라우저의 주소가 변경 -> 이동
    HttpServletResponse
      response
	: sendRedirect



2. include
  - 페이지 추가(기존 버퍼에 추가)
  - 기존 버퍼를 비우지 않고
  - <jsp:invlude를 만나면 버퍼를 추가
  - <jsp:invlude 다음부분 출력 물도 버퍼에 추가

  참고)
    <@ invlude file='...' />  차이점: 물리적으로 소스가 추가


3. include, mforward: 요청 처리중에 버퍼 처리
- 요청 데이터를 추가
<jsp:param name="매개변수명" value="값" />

★★★
HttpServletRequest
  request
    getParameter(String name)


HttpServletRequest request
	.getRequestDispatcher

RequestDispatcher
  :forward
  :include




MVC 웹개발 설계 모델★★★
  - 역할 분담 모델

M(Model) - 비지니스 로직을 구현하는 영역
  - Service(기능)
  - DTO(Data Transfer Object) : 데이터 전달 객체
      VO(value Object)
  - DAO(Data Access Object) : 데이터 접근 객체
  - Validator

  - 각 모든 객체가 하나의 기능을 수행하기 위해서 상호작용(객체 간의 의존성)

V(View) : 출력(jsp ...)


C(Controller) - 중재자 역할 : Servlet
  - HttpServletRequest, HttpServletResponse
  - 요청과 응답 사이
  - 요청 데이터를 가지고 적절한 처리를 할수있는 Model을 찾아서 의뢰
  - 처리결과를 응답을 통해서 출력



4. useBean
  Bean - 자바 객체
    - 데이터 전달용 객체에 특화
    - getter와 setter 위주의 객체(요즘에 거의 안씀)
    - 접근시 편의 기능 제공

    - 기본생성자를 통해서 객체 생성
      -> 반드시 기본 생성자가 정의되어야 동작

    - EL식 변수로서 각 getter를 속성명으로 접근 o
    - 

    - EL(Expression Language) - 표현식
    형식 -> ${ ...식... }
	       - 속성값(변수), 연산식, 간단한 메서드 호출


속성을 관리하는 내장 객체★★★
속성 -> EL 변수로 사용가능
1. PageContext pageContext
2. HttpServletRequest request
3. HttpSessin session
4. ServletContext application

pageContext, request, session, application

  속성을 관리하는 메서드 정의
  - 속성을 추가, 변경
  void setAttribute(String name, Object value);

  - 속성 조회
  Object getAttribute(String name);

  - 속성 제거
  void removeAttribibute(String name)




적용범위
pageContext < request < session < application 

적용의 우선순위 -> 범위가 좁을수록 먼저 우선순위
pageContext > request > session > application

속성 범위(scope)에 따른 EL식 변수
pageScope
requestScope
sessionScope
applicationScope






view(*.jsp)
  - 자바 코드 사용 지양
  - 태그 형태로만 사용
  - EL 언어

scope
  El 속성값 범위
    - page(기본값 - pageContext)
    - request
    - session
    - application





hello.jsp -> 번역 -> hello_jsp.java -> hello_jsp.class -> 실행
                         (확장된 서블릿)

_jspInit()
_jspService(HttpSevletRequest request, HttpSevletResponse response) : 요청 처리 메서드
_jspDestroy()



----------------------------------------------------

익스프레션 언어(EL 표현식)


1. 익스프레이션 언어의 기초문법
${ ...식... }

2. 익스프레션 언어의 내장 객체
param.이름 : 현재 바로 조회

request.getParameter
  - 요청 데이터는 메서드 상관없이 접근

paramValues

마침표(.)
대괄호 연산자([]) : 숫자, 단어(명칭), 특수문자 ...



익스프레션 언어의 연산자
1. 익스프레션 언어의 연산자
div  - 나눈 몫(/)
mod - 나머지(%)

lt(Iesser than) <
gt(greater than) >
le (lesser than equal) <=
ge (greater than equal) >=
eq (equal) ==
ne(not equal) !=


2. 엠프티 연산자
3. 대괄호 연산자와 마침표 연산자




























